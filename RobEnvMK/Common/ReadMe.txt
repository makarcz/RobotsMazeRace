
1. Introduction.

Life is tough on a 2-dimensional plane.
When you are just a lowly little bug (or let's better call it a bot, to avoid
unwanted association to the popular name used for software defect :-)) and
looking for an exit out of the maze, avoiding the walls at the same time,
since a single bump on the wall or an obstacle will kill you, there is no
space for error. There is also a competition. Who will reach the exit first?
The winner takes all!
The purpose of this application is to create a very simple sandbox environment
which is a 2 dimensional world of walls and obstacles. It can be a blank
bitmap, or a maze generated by another program, or an obstacle course which
you created yourself using a drawing studio application or even drawn by hand
and scanned into the computer. 
You decide.
Unleash AI bots into that environment, which you can code in any language of
your choice (examples in Perl are provided), which communicate with the
environment over standard I/O. Robot sends an action or query command to the
world and the world takes action and / or responds to the bot.
Play god and watch the action on the screen of your computer.

2. Theory of operation.

Application reads configuration file SimpleWorldSetup.ini which specifies
various parameters defining the way the world is rendered and paths to other
configuration files, e.g.: a path to the bitmap file which is used to produce
internal map of the world and defines the path to the robots definition file
and the path to robots configuration file.

World map is a small monochrome (B/W) bitmap picture, where white color
represents the empty space and black represents an obstacle or a wall.
The resolution of the file should be kept low, preferably no greater than
256 x 256 pixels.

That bitmap file is processed by the program to create internal map of the
world's 2-d environment, pre-computed trigonometric values, radar readings and
the matrix of the distances to the exit from each coordinate of the 2-d plain.
The ultimate goal of each bot is to find an exit and do it before the other
bots do. The concept of an Exit is just a point on the map. Currently the exit
point is hardcoded at coordinates 0, 0. (lower left corner)
Note that the bot program itself doesn't know and can't get the absolute
coordinates of its current location from the environment. That'd be cheating.
Therefore there is no GPS equivalent for robots in the robot-environment
communication protocol. All the robot has is eyes (radar sweep of its
surroundings showing distances to the walls / obstacles), nose (can 'smell'
in which general direction the exit is) and the pain sensory. (hit the wall
and die)
Bot progam may of course internally keep its own coordinates in its own
system of reference / internal map if the algorithm of the bot is that
sophisticated, however there is a slim to none chance that these coordinates
will match the absolute coordinates of the world. Keeping track of your own
movements is not cheating.
The goal of this game (if we can call it that, it is more of a simulation than
a game) is not necessarily to reach the exit. You can create a bot wandering
the world aimlessly without any goal or purpose and have fun watching it.
The important rule to remember though is that hitting the wall / obstacle
kills the bot, so it is a game over condition. The robot therefore must be at
least intelligent enough not to walk into obstacles or there will be no fun
in watching it kill itself after few steps and having to restart environment.
The environment will only terminate if all the robots has been killed.
Robot is killed when it walks into the wall or when it reaches the exit or
when it is not sending commands to the environment for a certain number of
main program loop iterations in a row. (currently hardcoded to 2000 steps)
As long as any robots continue their journeys through the maze, the program
will run.

You will be likely utilizing command '?Radar' heavily to gather data from
environment for next step determination.
It comes at a cost though as in response to that query the world sends back
360 values, radar distances for angles 0 - 359, starting right behind the bot
and continuing counter-clockwise around it. Bot can put these values in an
internal array to use in its path determining algorithm.
There is also a partial radar command that allows for the bot to obtain
a defined number of radar readings starting at specified angle. It may prove
useful for more detailed optimizations to the bot's algorithm in some cases,
however it is advised to read all the needed for next step calculations radar
values in a single step rather than separate smaller partial radar reads.
Because each command is a step and each bot gets to perform one step per each
main loop iteration, each extra step other than commands 'Move' or 'Turn' make
the bot appear slower than other bots which have algorithms with better ratio
of 'Move' / 'Turn' commands to no-action commands (e.g.: '?Radar', '?Eval',
?Killed). Time spent on calculations also slows down the robot. If robot
'thinks' too long it may be killed by timeout.
In fewer words - more efficient algorithm is rewarded.
The time that robot takes to make calculations before sending command to the
world is not being rationed or measured / distributed evenly between the bots.
The processing of the robots is strictly step based. However the input from
the robots output stream is processed asynchronously. Each time the robot
sends data, an event is raised in the application and the command sent from
robot to environment is added to robot's commands FIFO queue, which in turn
is read in each iteration of the main loop. Therefore if any bot chooses to
'think' (perform calculations) for a long time and does not send the command
to the environment within the time it takes environment to process single
loop frame, its command FIFO queue will be exhausted and then the loop will
skip over it and proceed to serve other robots, increasing the robots idle
steps counter at the same time. Exceed the maximum idle steps and the robot
will be booted out of the maze.
Another condition that will kill the robot is when robot is stuck within the
radius of 300 * robot_step_length for 10000 of continuous frame steps when
the command is sent to the environment. Frames that are idle (no command
received from robot) do not increase this counter, since they increase the
idle steps counter. In other words - if robot is stuck for 10000 steps,
environment will kill it. This event will be registered on the race report.
Asynchronous mode of processing of robots input makes the environment immune
to faulty robot process that has potential to hang the environment and stop
other robots from being processed. The robot that has inefficient algorithm
or a bug and stops sending commands will just appear to have stopped, but
other robots will happily chug away.

OK, back to the bot's AI:
You as a robot programmer can start by writing code of the robot that avoids
obstacles and / or follows the wall.
Once you have the obstacle avoidance sorted out, you can expand your algorithm
by adding exit seeking routine. Command '?Eval' is helpful in determination
which direction to take to reach the goal. This command has two variants,
one is a full circle query (360 values, like in '?Radar') and one that only
queries a single point.

After reading the robots configuration files, the robot processes are spawned,
the world and tiny robot avatars are rendered, the main loop starts and the
fun begins. The main loop of the world processes the input of each bot one
step per frame sequentially. Each bot is given a slice of attention and if
it's fast enough to make a decision and send a command within each loop
iteration, then the command will be processed and executed. Robot that is slow
to send commands may fail to produce the command to be sent to environment
when its turn comes. That is fine, as long as there are not too many (more
than 2000) idle steps counted in a row. In such case the robot process will be
assumed as unresponsive and will be terminated.

The race may take quite a long time. You may not have patience or time to
watch all of it in some cases. No worries. Just leave the program running,
make sure the Robot Status / Control is enabled in setup and go about your
other business. Once all the robots finished by either reaching the exit or
are killed, a short summary report will be produced in the text log control
on the Robot Status / Control dialog. It is alright to have the checkbox
'Hide text log' selected to speed up the program operation. Program will
re-enable the text log at the end so you will be able to see the summary
report when the race is finished.

Summary of the race rules:

- robot can't hit any walls, that's a game over condition
- robot can't idle (not send any commands) for more than MaxIdleSteps (*)
- robot can't be stuck within radius of StuckRadius * Step for more than
  MaxStuckSteps steps
- robot which reaches the exit first, wins
- environment stops when there are no more bots alive

(*) MaxIdleSteps, StuckRadius, Step and MaxStuckSteps are configuration setup
    parameters.
  
Corresponding counters for idle or stuck robots are reset when robot sends
the command or robot moves out of the 300 step size radius before they reach
corresponding threshold values.

3. World commands / Communication Protocol.

World accepts action and query commands. When the bot process is spawned,
STDIO channel of the thread is redirected to the STDIO channel of the bot
process, so whatever robot process prints to standard output is being sent
to the world which must read it and whatever world application prints to
standard output is being sent to the bot process, so it must be ready to
accept that on its standard input.
It is important to remember that buffering should be disabled on the
standard I/O in robot program or script.

E.g.:

In Perl, this is achieved by following statement:

$|=1;

Following bot control / query commands are currently supported:

 Move - moves the bot one step ahead. The length of the step is defined in
 		configuration setup. Due to the way the algorithm is designed, it
 		is recommended that step is configured to be much smaller than the
 		size of the robot. E.g.: robot size = 2, step = 0.1 works well.
 		This command doesn't send response to robot.
 
 Turn <angle> - rotates the robot by angle [rad] to the right (angle < 0)
			    or to the left (angle >= 0). Note that this is a relative
		        angle of turn to the current robot's absolute angle in the
		        environment's coordinates system. Please also note that
		        even though the angle argument is of real number, which
		        provide infinite number of values between 0 and 2 * PI for
		        all practical applications, the resolution of the radar
		        is discrete 360 degrees, to which the radians will be
		        converted internally.
		        This command doesn't send response to robot.
		        
 Kill - bot commits suicide, the thread is terminated and bot is removed from
 		the world's environment. This command may be useful while debugging
 		the bot's code, I don't see any other reasons why the bot would
 		want to terminate by its own will. After all this is a game over
 		condition.
 		This command doesn't send response to robot.
 		
 Exit - the same as 'Kill'.
 		
 ?Radar - query the radar function, will return a list of 360 floating point
		  values, where value at step #0 is the distance to the nearest
		  obstacle exactly behind the robot, value at step #1 is the distance
		  to the obstacle at 1 degree, value at step #2 is the distance to
		  the obstacle at 2 degrees and so on, going counter-clockwise.
		  Value at step #180 represents distance to the obstacle in front of
		  the bot. Value at step #90, to the right, at step #270 to the left.
		  You should get the idea by now.
		  
?PRadar <begin> <steps> - query the radar function, however instead of
						  returning full 360 degrees, returns <steps>
					      readings starting at <begin> angle in degrees.
		 
 ?Size - returns the size of the robot (diameter = 2 * r) in the world's
		 absolute units. The size of the world is determined by the resolution
		 of world's map bitmap file, from which all the radar rays are
		 calculated.
		 
 ?Killed - check if the robot was killed in previous step, returns 'true'
		   or 'false' string.
		   
 ?Eval <dist> - query the points located at <dist> distance from the robot
		 	  for their distances from the labirynth exit.
		 	  It's like a ?Radar, but instead of returning distances to the
		 	  obstacles, returns the negative values of distances of these
		      points to the exit. Robot program code can use these values
		      to decide its next step while looking for the exit in its
		      algorithm (the greater the value returned from ?Eval, the closer
		      given point is to the exit).
		      
 ?Eval <angle> <dist> - similar to above, however queries only a single point
		 	  		at angle <angle> radians and <dist> distance from the
		 			bot for that point's distance from exit, returns single
		 			value.
		 			
 Reset - causes robot coordinates to reset to their initial location and
		 rotate to 0 angle position (absolute angle of the environment's
		 coordinates).
		 This command doesn't send response to robot.
		 
 ?Step - returns the length of a step (for Move command) from setup.
		 Step should be less than the unit of the world's map resolution
		 and for more precise outcome of the bot position and collision
		 calculations and also for a more fluid movement it should also be
		 much lesser value than the size of the bot.
		 In other words, it is a floating point value and can be less than 1.

4. User interface.

The application look and controls are a bit rough, I admit I am not good at
this. The main application window displays the map and bots. Optionally the
robots status / control window opens and works independently of the main app.
window. If the main window has focus, there are several keystrokes available
to control the view of the environment / camera location and the simulation
process:

------------------------------------------------------------------------------
Key          Action
------------------------------------------------------------------------------
'p'          Simulation, toggle Pause / Run of the simulation.

'L'			 Camera, look to the left.

'R'			 Camera, look to the right.

'O'			 Camera, look down.

'K'			 Camera, look up.

'u'			 Camera, go forward.

'd'			 Camera, go backwards.

'f'			 Camera, look farther.

'F'			 Camera, look closer.

'r'			 Camera, slide to the right.

'l'			 Camera, slice to the left.

'o'			 Camera, float down.

'k'			 Camera, float up.

'x'			 Camera, rotate right around X axis.

'X'			 Camera, rotate left around X axis.

'y'			 Camera, rotate right around Y axis.

'Y'			 Camera, rotate left around Y axis.

'z'			 Camera, rotate right around Z axis.

'Z'			 Camera, rotate left around Z axis.

'='			 Light, amplify in X axis.

'-'			 Light, reduce in X axis.

']'			 Light, aplify in Y axis.

'['			 Light, reduce in Y axis.

'.'			 Light, amplify in Z axis.

','			 Light, reduce in Z axis.

'c'			 Simulation, reset.

'S'			 Configuration, update setup, reset.

'n'			 Control, select next robot as current.
             (makes sense when on-screen info is enabled in setup)

'1'			 Light, turn light in X axis ON / OFF.

'2'			 Light, turn light in Y axis ON / OFF.

'3'			 Light, turn light in Z axis ON / OFF.
------------------------------------------------------------------------------

Robot Status / Control dialog is an optional non-modal window (can be disabled
in setup) which displays information about robots current coordinates,
orientation (angle), radar reading in front of the bot, number of steps taken
and the log of the several recent commands executed by environment for given
robot (or all of them). It also contains light switches, a Kill button that
allows for manual termination of a robot and Manage button that allows to
configure the robots to be run by the environment. In the robot management
dialog user can add or delete robot, set robot's script / executable program,
process priority and the texture bitmap file.
The status / control window runs in parallel to the main window and is updated
in real time and is not blocking access to main windows, so user can switch
between both windows freely.
It is possible to turn off the main application window, so that the world
and robots are not visualized. It is advised though to have at least Robot
Status / Control window enabled to have some control over the application
and to be able to observe the robots performance at least by the coordinates
and logs.

To start application in sumulation mode, run RobEnvMK.exe program.
To start application in setup mode, add swich /c to the command like.
Once the setup is completed, click OK in the configuration dialog window and
program will enter simulation mode.

5. Configuration Setup.

Run command:

   RobEnvMK.exe /c
   
to enter setup, or press Shift-S while simulation is running.

What does the environment need to run?
At least one robot program or script, robot configuration file, robot texture
bitmap file, world map bitmap file and world configuration file.

SimpleWorldSetup.ini - world configuration file, should be present in the same
                       folder as the executable program.
                       
The format of the file is:

Parameter Value

E.g.:

MaxIdleSteps 4000
StuckRadius 400
MaxStuckSteps 15000
CameraX 123.4
CameraY -60
CameraZ -344.0
LookAtX 0.0
LookAtY 5.0
LookAtZ 8.0
LightX 300.0
LightY -60.0
LightZ 400.0
MapImagePath Lab04.bmp
PlugInCfgPath robot_perl3.cfg
RotateX -0.55
RotateY 0.0
RotateZ 0.0
Step 0.1
ShowOnScreenInfo False
SightDistance 500
RandomRobotStart True
RobotStartX 10
RobotStartY 10
RobotSize 2
HWVertexProc True
VisualizeWorld True
ShowStatusWindow True
CloseWhenAllBotsQuit True

Description of the parameters:

MaxIdleSteps - maximum amount / number of consecutive steps or main loop
			   frames during which robot doesn't send any input / commands
			   to the environment. When that number is exceeded, robot will
			   be terminated.
			   
StuckRadius - this number multiplied by value of Step is a radius within which
              robot operates (from certain start point or counter reset
              point) without leaving this area for amount of steps or main
			  loop frames defined by MaxStuckSteps before it is considered
			  as stuck in this area or looping or just too slow. Robot is
			  terminated if it cannot leave this radius before the counter
              reaches MaxStuckSteps.
              
MaxStuckSteps - maximum amount / number of consecutive steps or main loop
				frames during which robot doesn't leave the radius calculated
				as StuckRadius * Step. The counter that counts the steps is
				reset at the beginning or when robot leaves this radius before
				counter reaches MaxStuckSteps. The new reference point is also
				reset at that time as a new location from which the distance
				is being measured and compared to value of StuckRadius * Step.
				
CameraX, CameraY, CameraZ - coordinates of the camera in the 3-D environment.

LookAtX, LookAtY, LookAtZ - orientation of the camera in the 3-D environment.

LightX, LightY, LightZ - coordinates of the light source.

MapImagePath  - determines the path / filename to the world map bitmap file.

PlugInCfgPath -  determines the path to the robots configuration file.

The format if this file is as follows:

Program Priority TextureFile

E.g.:

.\\perlbot_new.pl Normal red1.bmp
.\\perlbot5.pl Normal metal5a.bmp
.\\perlbot3.pl Normal green1.bmp

This file can be created manually or using Manage button on the Robot
Status / Control dialog.

RotateX, RotateY, RotateZ - camera rotation in all 3 axis.

Step - determines the length of the single step performed by Move command.

ShowOnScreenInfo - True / False, turns the displaying of the robot position,
				   angle and command directly on the main windows where the
				   world is rendered on or off.
				   
SightDistance - this will be the maximum possible radar distance reading.
                Any obstacle further than this distance will not be seen.
                
RandomRobotStart - True / False, decides if the robot's initial coordinates
				   are generated randomly or are predefined.
				   
RobotStartX, RobotStartY - initial coordinates of the robots.

RobotSize - this defines how big the robot's body will be (diameter).

HWVertexProc - True / False, enable or disable hardware vertex processing.

VisualizeWorld - True / False, enable or disable main application window.

ShowStatusWindow - True / False, enable or disable Robot Status / Control
                   window.
                   
CloseWhenAllBotsQuit - True / False, if True, application will quit when all
                       robots are killed.